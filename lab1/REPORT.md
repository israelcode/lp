# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Чекушкин Д.И

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|    16.10.17  |       4-      |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение
Список это структура с последовательным доступом. Списки не требуют объявления размера, они похожи на массивы в других языках. 

## Задание 1.1: Предикат обработки списка

    count2([],_,Result) - подсчет числа вхождений элемента (список,элемент,результат)

Примеры использования:

    | ?- count2([a,b,c,a,a,d],a,Y).
    Y = 3
    yes
    | ?- count2([b,c,d],a,Y).      
    Y = 0
    yes
    | ?- count2([],a,Y).     
    Y = 0
    yes
    | ?- count2([a,a,a,t,t,t,a,s,d,f,g],a,Y).
    Y = 4
    yes

Реализация:

    count2([],_,0).
    count2([A|B],A,X):-!,count2(B,A,Y), X is Y+1.
    count2([A|B],C,X):-count2(B,C,X).

Пустой список=0. Если есть в "голове", отсекаем ее, делаем "+1", смотрим "хвост". В противном случае сразу "хвост".

## Задание 1.2: Предикат обработки числового списка

    max([Head|Tail],Result) - вычисление максимального элемента (список, результат)

Пример использования:

    | ?- max([1,2,3],Result).
    Result = 3
    yes
    | ?- max([1,2,3|[4,5]],Result).  
    Result = 5
    yes
    | ?- max([],Result).           
    no
    | ?- max([1,1],Result).
    Result = 1
    yes

Реализация:

    max([Head|Tail],Result):-
            max(Tail,Result),Result>Head,!.
        max([Head|_],Head).
Рекурсивный обход.

## Задание 2: Реляционное представление данных

Преимущества: простая форма отображения; строгие правила проектирования, основаные на математическом аппарате.
Недостатки: не всегда данные можно представить в виде таблиц; низкая скорость доступа к данным; трудоемкость.

Преимущества и недостатки данного представления: доступно для понимания с первого взгляда, но большое количество кода.

    findall(X,grade(_,_,'НАЗВАНИЕ_ПРЕДМЕТА',X),C),sum_list(C,Sum), getLenList(C,N), LPmid is Sum/N, write(LPmid). - с помощью findall добавляем в список С все оценки, суммируем их, ищем длинну списка, делим первое на второе.

    findall(X,grade(НОМЕР_ГРУППЫ,X,_,2),C), getLenList(C,N1), write(N1). - Ищем двоечников, определяем их количество.

    findall(X,grade(_,X,'НАЗВАНИЕ_ПРЕДМЕТА',2),C), getLenList(C,LP), write(LP). - Ищем двоечников, по предметам, определяем количество.
## Выводы

 Во время выполнения лабораторной работы я ознакомился с языком Пролог. Язык состоит из небольшого набора механизмов: сопоставление с образцом, перебор с возвратом. Язык подходит для решения задач, где рассматриваются объекты и отношения между ними. Разобрался в устройстве стандартных предикатов, реализовал свои версии. Узнал о реляционных базах данных, научился использовать предикаты для поиска списка всех решений некоторого предиката.
 Лабораторная работа заставила меня взглянуть на программирование по-новому. Пролог является декларативным языком. Программа выражается в терминах отношений, представленных в виде фактов и правил. 



