#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Чекушкин Д. И.
## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|  26.12.17    |     3         |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Методом поиска в пространстве состояний удобно решать задачи, где заданно исходное состояние проблемы и множество операций которые можно использовать для изменения текущего состояния проблемы при этом неохожимо реализовать тест завершения — проверку, достигнуто ли требуемое конечное состояние или найдено решение проблемы.

Все методы перебора в пространстве состояний могут быть смоделированы с помощью графа. Именно поэтому Пролог удобен для решения таких задач.

## Задание

Вариант 2

Три миссионера и три каннибала хотят переправиться с левого берега реки на правый. Как это сделать за минимальное число шагов, если в их распоряжении имеется трехместная лодка и ни при каких обстоятельствах (в лодке или на берегу) миссионеры не должны оставаться в меньшинстве.

## Принцип решения

    Левый берег: K, K, K, M, M, M  ----- Правый берег: 
    Левый берег: K, K, M, M        ----- Правый берег: K, M
    Левый берег: K, K, M, M, M     ----- Правый берег: K
    Левый берег: K, M              ----- Правый берег: K, K, M, M
    Левый берег: K, K, M, M        ----- Правый берег: K, M
    Левый берег: K                 ----- Правый берег: K, K, M, M, M
    Левый берег: K, M              ----- Правый берег: K, K, M, M
    Левый берег:                   ----- Правый берег: K, K, K, M, M, M


  Проверка на количество каннибалов и миссонеров. 

    check(L):-
      delete(L, 'K', L1),
      length(L1, N), X is N,
      delete(L, 'M', L2),
      length(L2, M), Y is M, 
      (X >= Y; X==0).

Один из предикатов move
 
    % один миссонер и один каннибал вправо
    move(A, B):-
      append(Lt, ['right' | Rt], A),
      append(Begin, ['K', 'M' | T], Lt),
      append(Rt, ['K', 'M'], Rt2),
      check(Rt2),
      sort_items(Rt2, RSORT),
      append(Begin, T, L),
      check(L),
      append(L, ['left'], L1),
      append(L1, RSORT, B).

## Результаты

    search_dpth((['K','K','K','M','M','M','right']), ([_, 'K','K','K','M','M','M'])).

    [K, K, K, M, M, M, right]
    [K, K, M, M, left, K, M]
    [K, K, M, M, M, right, K]
    [K, M, left, K, K, M, M]
    [K, K, M, M, right, K, M]
    [K, left, K, K, M, M, M]
    [K, M, right, K, K, M, M]
    [left, K, K, K, M, M, M]
    time:0.0052332878112792976


    search_bdth((['K','K','K','M','M','M','right']), ([_, 'K','K','K','M','M','M'])).

    [K, K, K, M, M, M, right]
    [K, K, M, M, left, K, M]
    [K, K, M, M, M, right, K]
    [K, M, left, K, K, M, M]
    [K, K, M, M, right, K, M]
    [K, left, K, K, M, M, M]  
    [K, M, right, K, K, M, M]
    [left, K, K, K, M, M, M]
    time:0.024544715881347656


    search_id((['K','K','K','M','M','M','right']), ([_, 'K','K','K','M','M','M'])).

    [K, K, K, M, M, M, right]
    [K, K, M, M, left, K, M]
    [K, K, M, M, M, right, K]
    [K, M, left, K, K, M, M]
    [K, K, M, M, right, K, M]
    [K, left, K, K, M, M, M]
    [K, M, right, K, K, M, M]
    [left, K, K, K, M, M, M]
    time:0.01555490493774414



## Выводы

Поиск в глубину оказался самым эффективным и это меня немного удивило, я ожидал увидеть поиск с итерационным углублением. Но он оказался вторым. Поиск с итерационным углублением является чем-то средним между поиском в ширину и в глубину и хорошо справляется с простыми задачами. Поиск в ширину оказался худшим из-за большого использования памяти.




